---
title: "_Cardinal 3_: User guide for mass spectrometry imaging analysis"
author: "Kylie Ariel Bemis"
date: "Revised: April 7, 2024"
output:
  BiocStyle::html_document:
  toc: true
vignette: >
  %\VignetteIndexEntry{1. Cardinal 2: User guide for mass spectrometry imaging analysis}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r style, echo=FALSE, results='asis'}
BiocStyle::markdown()
```

```{r setup, echo=FALSE, message=FALSE}
library(Cardinal)
setCardinalVerbose(FALSE)
```

# Introduction 

## Cardinal 3.6

*Cardinal 3.6* is a major update with breaking changes. It bring support many of the new low-level signal processing functions implemented for *matter 2.4* and *matter 2.6*. Almost the entire *Cardinal* codebase has been refactored to support these improvements.

The most notable of the new features include:

- Redesign class hierarchy that includes a greater emphasis on spectra: `SpectralImagingData`, `SpectralImagingArrays`, and `SpectralImagingExperiment` lay the groundwork for the new data structures

- Updated `MSImagingExperiment` class with a new counterpart `MSImagingArrays` class for better representing raw spectra.

- New spectral processing methods in `smooth()`:

  + Improved Gaussian filtering
  + Bilateral and adaptive bilateral filtering
  + Nonlinear diffusion filtering
  + Guided filtering
  + Peak-aware guided filtering
  + Savitsky-Golay smoothing

- New spectral alignment methods in `recalibrate()`:

  + Local maxima-based alignment using local regression
  + Dynamic time warping
  + Correlation optimized warping

- New spectral baseline reduction methods in `reduceBaseline()`:

  + Interpolation from local minima
  + Convex hull estimation
  + Sensitive nonlinear iterative peak (SNIP) clipping
  + Running medians

- New peak picking methods in `peakPick()`:

  + Derivative-based noise estimation
  + Quantile-based noise estimation
  + SD/MAD-based noise estimatino
  + Dynamic peak filtering
  + Continuous wavelet transform (CWT)

- Improved `image()` contrast enhancement:

  + Improved histogram equalization
  + Contrast-limited adaptive histogram equalization (CLAHE)

- Improved `image()` spatial smoothing:

  + Improved Gaussian filtering
  + Bilateral and adaptive bilateral filtering
  + Nonlinear diffusion filtering
  + Guided filtering

- All statistical analysis methods are improved and updated

  + New and improved `crossValidate()` method
  + New dimension reduction method `NMF()`
  + Updated `PCA()` and `spatialFastmap()`
  + Updated `PLS()` and `OPLS()` with new algorithms
  + Updated `spatialKMeans()` with better initializations
  + Updated `spatialShrunkenCentroids()` with better initializations
  + Updated `spatialDGMM()` with improved stability
  + Updated `meansTest()` with improved data preparation
  + New `SpatialResults` output with simplified interface

And many other updates! Many redundant functions and methods have been merged to simplify and streamline workflows. Many unnecessary functions and methods have been deprecated.

Major improvements from earlier versions are further described below.

## Cardinal 3

*Cardinal 3* lays the groundwork for future improvements to the existing toolbox of pre-processing, visualization, and statistical methods for mass spectrometry (MS) imaging experiments. *Cardinal* has been updated to support *matter 2*, and legacy support has been dropped.

Despite minimal user-visible changes in *Cardinal* (at first), the entire *matter* package that provides the backend for *Cardinal*'s computing on larger-than-memory MS imaging datasets has been rewritten. This should provide more robust support for larger-than-memory computations, as well as greater flexibility in handling many data files in the future.

Further changes will be coming soon to *Cardinal 3* in future point updates that are aimed to greatly improve the user experience and simplify the code that users need to write to process and analyze MS imaging data.

Major improvements from earlier versions are further described below.

## Cardinal 2

*Cardinal 2* provides new classes and methods for the manipulation, transformation, visualization, and analysis of imaging experiments--specifically MS imaging experiments.

MS imaging is a rapidly advancing field with consistent improvements in instrumentation for both MALDI and DESI imaging experiments. Both mass resolution and spatial resolution are steadily increasing, and MS imaging experiments grow increasingly complex.

The first version of *Cardinal* was written with certain assumptions about MS imaging data that are no longer true. For example, the basic assumption that the raw spectra can be fully loaded into memory is unreasonable for many MS imaging experiments today.

*Cardinal 2* was re-written from the ground up to handle the evolving needs of high-resolution MS imaging experiments. Some advancements include:

- New imaging experiment classes such as `ImagingExperiment`, `SparseImagingExperiment`, and `MSImagingExperiment` provide better support for out-of-memory datasets and a more flexible representation of complex experiments

- New imaging metadata classes such as `PositionDataFrame` and `MassDataFrame` make it easier to manipulate experimental runs, pixel coordinates, and *m/z*-values by storing them as separate slots rather than ordinary columns

- New `plot()` and `image()` visualization methods that can handle non-gridded pixel coordinates and allow assigning the resulting plot (and data) to a variable for later re-plotting

- Support for writing imzML in addition to reading it; more options and support for importing out-of-memory imzML for both *"continuous"* and *"processed"* formats

- Data manipulation and summarization verbs such as `subset()`, `aggregate()`, and `summarizeFeatures()`, etc. for easier subsetting and summarization of imaging datasets

- Delayed pre-processing via a new `process()` method that allows queueing of delayed pre-processing methods such as `normalize()` and `peakPick()` for later execution

- Parallel processing support via the *BiocParallel* package for all pre-processing methods and any statistical analysis methods with a `BPPARAM` option

Classes from older versions of Cardinal should be coerced to their *Cardinal 2* equivalents. For example, to return an updated `MSImageSet` object called `x`, use `as(x, "MSImagingExperiment")`.



# Installation

*Cardinal* can be installed via the *BiocManager* package.

```{r install, eval=FALSE}
install.packages("BiocManager")
BiocManager::install("Cardinal")
```

The same function can be used to update *Cardinal* and other Bioconductor packages.

Once installed, *Cardinal* can be loaded with `library()`:

```{r library, eval=FALSE}
library(Cardinal)
```



# Data import

*Cardinal* natively supports reading and writing imzML (both "continuous" and "processed" types) and Analyze 7.5 formats via the `readMSIData()` and `writeMSIData()` functions.

The imzML format is an open standard designed specifically for interchange of mass spectrometry imaging datasets. Vendor-specific raw formats can be converted to imzML with the help of free applications available online at [](http://www.imzml.org).

## Reading "continuous" imzML

We can read an example of a "continuous" imzML file from the `CardinalIO` package:

```{r read-imzML-continuous}
path_c <- CardinalIO::exampleImzMLFile("continuous")
path_c
mse1 <- readMSIData(path_c)
mse1
```

A "continuous" imzML file contains mass spectra where all of the spectra have the same m/z values. It is returned as an `MSImagingExperiment` object, which contains both the spectra and the experimental metadata.



## Reading "processed" imzML

We can also read an example of a "processed" imzML file from the `CardinalIO` package:

```{r read-imzML-processed}
path_p <- CardinalIO::exampleImzMLFile("processed")
path_p
msa1 <- readMSIData(path_p)
msa1
```

A "processed" imzML file contains mass spectra where each spectrum has its own m/z values. Despite the name, it can still contain profile spectra. For "processed" imzML, the data is returned as an `MSImagingArrays` object.






# Data structures for MS imaging

*Cardinal 3.6* introduces a simple set of new data structures for organizing data from MS imaging experiments.

![Cardinal classes](Cardinal-class-diagram.pdf)

- `SpectraArrays`: Storage for high-throughput spectra

- `SpectralImagingData`: Virtual container for spectral imaging data, i.e., spectra with spatial metadata

- `MSImagingArrays`: Specializes `SpectralImagingData` (via `SpectralImagingExperiment`)  for representing raw mass spectra where each spectrum has its own m/z values

- `MSImagingExperiment`: Specializes `SpectralImagingData` (via `SpectralImagingArrays`)  for representing mass spectra where all spectra have the same m/z values

These are further explored in the next sections.




## `MSImagingArrays`: Mass spectra with differing m/z values

In *Cardinal*, mass spectral data with differing m/z values are stored in `MSImagingArrays` objects.

```{r show-MSImagingArrays}
msa1
```

An `MSImagingArrays` object is conceptually a list of mass spectra with a companion data frame of spectrum-level pixel metadata.

This dataset contains 9 mass spectra. It can be subset like a list:

```{r show-MSImagingArrays}
msa1[1:3]
```

### Accessing spectra arrays with `spectraData()`

The spectral data can be accessed with `spectraData()`.

```{r spectraData-MSImagingArrays}
spectraData(msa1)
```

The list of spectral data arrays are stored in a `SpectraArrays` object. An `MSImagingArrays` object must have at least two arrays named "mz" and "intensity", which are lists of the m/z arrays and intensity arrays.

The `spectra()` accessor can be used to access specific spectra arrays.

```{r spectra-accessor}
spectra(msa1, "mz")
spectra(msa1, "intensity")
```

Alternatively, we can use the `mz()` and `intensity()` accessors to get these specific arrays.

```{r intensity-accessor}
mz(msa1)
intensity(msa1)
```

Note that the full spectra are not fully loaded into memory. Instead, they are represented as out-of-memory `matter` lists. For the most part, these lists can be treated as ordinary R lists, but the spectra are only loaded from storage on-the-fly as they are accessed.

### Accessing pixel metadata with `pixelData()`

The spectrum-level pixel metadata can be accessed with `pixelData()`. Alternatively, `pData()` is a shorter alias that does the same thing.

```{r pixelData-MSImagingArrays}
pixelData(msa1)
pData(msa1)
```

The pixel metadata is stored in a `PositionDataFrame`, with a row for each mass spectrum in the dataset. This data frame stores position information, run information, and all other spectrum-level metadata.

The `coord()` accessor retrieves the columns giving the positions of the spectra.

```{r coord-accessor}
coord(msa1)
```

Use `runNames()` to access the names of the experimental runs (by default set to the file name) and `run()` to access the run for each spectrum.


```{r run-accessor}
runNames(msa1)
head(run(msa1))
```

This data frame is also used to store any other spectrum-level metadata or statistical summaries.




## `MSImagingExperiment`: Mass spectra with the same m/z values

In *Cardinal*, mass spectral data with the same m/z values are stored in `MSImagingExperiment` objects.

```{r show-MSImagingExperiment}
mse1
```

An `MSImagingExperiment` object is conceptually a matrix where the mass spectra are columns. The rows represent the flattened images for each mass feature.

This dataset contains 9 mass spectra each with the same 8,399 m/z values. It can be subset like a matrix:

```{r subset-MSImagingExperiment}
mse1[1:500, 1:3]
```

For an `MSImagingExperiment`, the spectral data are stored as a single matrix of intensities that can be accessed with `spectra()`.

```{r spectraData-MSImagingExperiment}
spectraData(mse1)
spectra(mse1)
```
The spectrum-level pixel metadata is accessible via `pixelData()` just like `MSImagingArrays`.

```{r pixelData-MSImagingExperiment}
pixelData(mse1)
```

The primary difference between `MSImagingExperiment` and `MSImagingArrays` is that that all of spectra share the same m/z values, so `MSImagingExperiment` can store feature metadata.


### Accessing feature metadata with `featureData()`

The feature metadata can be accessed with `featureData()`. Alternatively, `fData()` is a shorter alias that does the same thing.

```{r featureData-accessor}
featureData(mse1)
fData(mse1)
```

Because all of the mass spectra share the same m/z values, a single vector of m/z values can be accessed using `mz()`.

```{r mz-accessor}
head(mz(mse1))
```

This data frame is also used to store any other feature-level metadata or statistical summaries.


### Building from scratch

Typically data is read into R using `readMSIData()`, but sometimes it is necessary to build a `MSImagingExperiment` object from scratch. This may be necessary if trying to import data formats other than imzML or Analyze 7.5.

```{r constructor}
set.seed(2020)
s <- simulateSpectra(n=9, npeaks=10, from=500, to=600)

coord <- expand.grid(x=1:3, y=1:3)
run <- factor(rep("run0", nrow(coord)))

fdata <- MassDataFrame(mz=s$mz)
pdata <- PositionDataFrame(run=run, coord=coord)

out <- MSImagingExperiment(spectraData=s$intensity,
    featureData=fdata,
    pixelData=pdata)
out
```

For loading other data formats into R, `read.csv()` and `read.table()` can be used to read CSV and tab-delimited text files, respectively.

Likewise, `write.csv()` and `write.table()` can be used to write pixel metadata and feature metadata after coercing them to an ordinary R `data.frame` with `as.data.frame()`.

Use `saveRDS()` and `readRDS()` to save and read and entire R object such as a `MSImagingExperiment`. Note that if intensity data is to be saved as well, it should be pulled into memory and coerced to an R matrix with `as.matrix()` first. However, it is typically better to write an imzML file using `writeMSIData()`.







# Visualization

Visualization of mass spectra and molecular ion images is vital for exploratory analysis of MS imaging experiments. *Cardinal* provides `plot()` methods for plotting mass spectra and a`image()` methods for plotting images.

We will use simulated data for visualization.

```{r simulate}
set.seed(2020)
mse <- simulateImage(preset=6, dim=c(32,32))
mse
```

## Visualizing spectra with `plot()`

Use `plot()` to plot mass spectra. Below we plot the 463rd and 628th mass spectra in the dataset

```{r plot-i, fig.height=3, fig.width=9}
plot(mse, i=c(496, 1520))
```

Alternatively, we can specify the coordinates.

```{r plot-coord, fig.height=3, fig.width=9}
plot(mse, coord=list(x=16, y=16)
```

We can use `superpose` to overlay the mass spectra and `xlim` to control the mass range.

```{r plot-superpose, fig.height=3, fig.width=9}
plot(mse, i=c(496, 1520), xlim=c(1000, 1250),
    superpose=TRUE)
```

## Visualizing images with `image()`

Use `image()` to plot ion images. Below we plot the image for the 2,489th m/z value.

```{r image-i, fig.height=4, fig.width=9}
image(mse, i=2769)
```

Alternatively, we can specify the m/z value. The closest matching m/z value will be used.

```{r image-mz, fig.height=4, fig.width=9}
image(mse, mz=1200.2)
```

Use `tolerance` to sum together the images for a all m/z values within a certain tolerance.

```{r image-plusminus, fig.height=4, fig.width=9}
image(mse, mz=1200.2, tolerance=0.5, units="mz")
```

By default, images from all experimental runs are plotted. Use `run` to specify specific runs to plot by name or index.

```{r image-run, fig.height=4, fig.width=5}
image(mse, mz=1200.2, run="runA1")
```

Alternatively, use `subset` to plot an arbitrary subset of pixels.

```{r image-run, fig.height=4, fig.width=5}
image(mse, mz=1200.2, subset=mse$circleA)
```

Multiplicative variance in spectral intensities can cause images to be noisy and dark due to hot spots.

Often, images may require some type of processing and enhancement to improve interpretation.

```{r image-smooth, fig.height=4, fig.width=9}
image(mse, mz=1200.2, smooth="gaussian")
```

```{r image-contrast, fig.height=4, fig.width=9}
image(mse, mz=1200.2, enhance="histogram")
```

Multiple images can be superposed with `superpose=TRUE`. Use `scale=TRUE` to rescale all images to the same intensity range.

```{r image-superpose, fig.height=4, fig.width=9}
image(mse, mz=c(473.9, 1618.7), superpose=TRUE,
    enhance="adaptive", scale=TRUE)
```


## Region-of-interest selection

Use `selectROI()` to select regions-of-interest on an ion image. It is important to specify a subset so that selection is only made on a single experimental run, otherwise results may be unexpected. The form of `selectROI()` is the same as `image()`.

```{r select-ROI, eval=FALSE}
sampleA <- selectROI(mse, mz=1200.2, subset=run(mse) == "run0")
sampleB <- selectROI(mse, mz=1200.2, subset=run(mse) == "run1")
```
`selectROI()` returns a logical vector specifying which pixels from the imaging experiment are contained in the selected region.

`makeFactor()` can then be used to combine multiple logical vectors (e.g., from `selectROI()`) into a single factor.

```{r makeFactor, eval=FALSE}
regions <- makeFactor(A=sampleA, B=sampleB)
```


## Saving plots and images

Plots and images can be saved to a file by using R's built-in graphics devices.

Use `pdf()` to initialize a PDF graphics device, create the plot, and then use `dev.off()` to turn off the graphics device.

Any plots printed while the graphics device is active will be saved to the specified file(s).


```{r pdf, eval=FALSE}
pdf_file <- paste0(tempfile(), ".pdf")

pdf(file=pdf_file, width=9, height=4)
image(mse, mz=1200.2)
dev.off()
```

Graphics devices for `png()`, `jpeg()`, `bmp()`, and `tiff()` are also available. See their documentation for usage.


## Dark themes

While many software for MS imaging data use a light-on-dark theme, *Cardinal* uses a dark-on-light theme by default. However, a dark theme is also provided with `style="dark`.

```{r dark-mode-1, fig.height=4, fig.width=9}
image(mse, mz=1200.2, style="dark")
```




## A note on plotting speed

While plotting spectra should typically be fast, plotting images can be be (much) slower for large out-of-memory datasets.

This is due to the way the spectra are stored in imzML and Analyze files. Exracting the images simply takes longer than reading the spectra.

For the fastest visualization of images, experiments should be coerced to an in-memory matrix.

Also note that all *Cardinal* visualizations produce a `plot()`-able object that can be assigned to a variable and `plot()`-ed later without the need to read the data again. Some parameters can even be updated this way, such as smoothing, contrast enhancement, and scaling.

```{r print, eval=FALSE}
p <- image(mse, mz=1200.2)
plot(p, smooth="guided")
```

This is useful for re-creating or updating plots without accessing the data again.





# Common operations on `MSImagingExperiment`

## Subsetting

`MSImagingExperiment` are matrix-like objects that can be subsetted using the `[` operator.

When subsetting, the "rows" are the mass features, and the "columns" are the pixels.

```{r subset-1}
# subset first 10 mass features and first 5 pixels
mse[1:10, 1:5]
```

Subsetting the dataset this way requires knowing the desired row and column indices.

`features()` returns row indices based on specified feature metadata.

```{r features}
# get row index corresponding to m/z 1200
features(mse, mz=1200)

# get row indices corresponding to m/z 1199 - 1201
features(mse, 1199 < mz & mz < 1201)
```

`pixels()` returns column indices based on specified pixel metadata.

```{r pixels}
# get column indices corresponding to x = 10, y = 10 in all runs
pixels(mse, coord=list(x=10, y=10))

# get column indices corresponding to x <= 3, y <= 3 in "run0"
pixels(mse, x <= 3, y <= 3, run == "run0")
```

These methods can be used to determine row/column indices of particular *m/z*-values or pixel coordinates to use for subsetting.

```{r subset-2}
fid <- features(mse, 1199 < mz & mz < 1201)
pid <- pixels(mse, x <= 3, y <= 3, run == "run0")
mse[fid, pid]
```

## Slicing

`MSImagingExperiment` represents the data as a matrix, where each column is a mass spectrum, rather than as a true "data cube". This is typically simpler when operating on the mass spectra, and more space efficient when the data is pixel-sparse (i.e., non-rectangular).

Sometimes, however, it is useful to index into the data as an actual "data cube", with explicit array dimensions for each spatial dimension.

Use `slice()` to slice an `MSImagingExperiment` as a data cube and extract images.

```{r slice}
# slice image for first mass feature
a <- slice(mse, 1)
dim(a)
```

Any arguments to `slice()` are passed to `features()`, making it easy to select the desired image slices.

By default, array dimensions with only one level are dropped; use `.preserve=TRUE` to keep all dimensions.

```{r slice-mz}
# slice image for m/z 1200
a2 <- slice(mse, mz=1200, drop=FALSE)
dim(a2)
```

Note that when plotting images from raw arrays, the images are upside-down due to differing coordinate conventions used by `graphics::image()`.

```{r slice-image, fig.height=4, fig.width=4}
image(a2[,,1,1], col=bw.colors(100))
```

## Combining

Because `MSImagingExperiment` is matrix-like, `rbind()` and `cbind()` can be used to combine multiple `MSImagingExperiment` objects by "row" or "column", assumping certain conditions are met.

Use `cbind()` to combine datasets from different experimental runs. The *m/z*-values must match between all datasets to succesfully combine them.

```{r cbind-divide}
# divide dataset into separate objects for each run
mse_run0 <- mse[,run(mse) == "run0"]
mse_run1 <- mse[,run(mse) == "run1"]
mse_run0
mse_run1
```

```{r cbind-recombine}
# recombine the separate datasets back together
mse_cbind <- cbind(mse_run0, mse_run1)
mse_cbind
```

Some processing may be necessary to ensure datasets are compatible before combining them.

## Getters and setters

Most components of an `MSImagingExperiment` that can be accessed through getter functions like `pixelData()`, `featureData()`, and `imageData()`, can also be re-assigned with analogous setter functions. These can likewise be used to get and set columns of the pixel and feature metadata.

`pData()` and `fData()` are aliases for `pixelData()` and `featureData()`, respectively.

The `$` operator will access the corresponding columns of `pixelData()`.

```{r pData-set}
mse$region <- makeFactor(circle=mse$circle,
							bg=!mse$circle)
pData(mse)
```

`iData()` can be used to access elements of the `imageData()` list by name or index.

Using `iData()` with no arguments besides the dataset will get or set the first element of `imageData()`. Providing a name or index will get or set that element.

```{r iData-set}
iData(mse, "log2intensity") <- log2(iData(mse) + 1)
imageData(mse)
```

For `MSImagingExperiment`, `spectra()` is an alias for `iData()`.

```{r spectra-get}
spectra(mse, "log2intensity")[1:5, 1:5]
```

Whether or not the spectra have been centroided or not can be accessed using `centroided()`

```{r centroided-get}
centroided(mse)
```

This can also be used to set whether the spectra should be treated as centroided or not.

```{r centroided-set, eval=FALSE}
centroided(mse) <- FALSE
```

## Summarization (e.g., mean spectra)

*Cardinal 2* implements several convenient data manipulation verbs for subsetting and summarizing `MSImagingExperiment` objects.

- `subset()` subsets an `MSImagingExperiment`

- `subsetFeatures()` subsets an `MSImagingExperiment` by row, i.e., mass features

- `subsetPixels()` subsets an `MSImagingExperiment` by column, i.e., pixels

- `aggregate()` summarizes an `MSImagingExperiment` by either feature or pixel

- `summarizeFeatures()` summarizes an `MSImagingExperiment` by feature (e.g., mean spectrum)

- `summarizePixels()` summarizes an `MSImagingExperiment` by pixel (e.g., TIC)

The `%>%` operator can be used to chain these operations together. For file-based data, the subsetting should be quick, as only metadata is modified.

```{r manip}
# subset by mass range
subsetFeatures(mse, mz > 700, mz < 900)

# subset by pixel coordinates
subsetPixels(mse, x <= 3, y <= 3, run == "run0")

# subset by mass range + pixel coordinates
subset(mse, mz > 700 & mz < 900, x <=3 & y <= 3 & run == "run0")

# chain verbs together
mse %>%
	subsetFeatures(mz > 700, mz < 900) %>%
	subsetPixels(x <= 3, y <= 3, run == "run0")

# calculate mean spectrum
summarizeFeatures(mse, "mean", as="DataFrame")

# calculate tic
summarizePixels(mse, c(tic="sum"), as="DataFrame")

# calculate mean spectrum of circle region
mse %>%
	subsetPixels(region == "circle") %>%
	summarizeFeatures("mean", as="DataFrame")
```

## Bring data into memory

By default, *Cardinal 2* does not load the spectra from imzML and Analyze files into memory, but retrieves them from files when necessary.

For very large datasets, this is necessary and memory-efficient.

However, for datasets that are known to fit in computer memory, this may be unnecessarily slow, especially when plotting images (which are perpendicular to how data are stored in the files).

```{r matter}
# coerce spectra to file-based matter matrix
spectra(mse) <- matter::as.matter(spectra(mse))

spectra(mse)
imageData(mse)
```

Use `as.matrix()` on the `spectra()` to pull the spectra into memory as a dense matrix.

```{r}
spectra(mse) <- as.matrix(spectra(mse))
imageData(mse)
```

## Coercion to/from other classes

Use `as()` to coerce between different `MSImagingExperiment` sub-classes.

```{r coerce}
mse3
as(mse3, "MSContinuousImagingExperiment")
```

This will often change the underlying data representation, so some information may be lost depending on the coercion.

Objects of the older `MSImageSet` class can also be coerced to `MSImagingExperiment` this way.

```{r coerce-2, eval=FALSE}
# requires CardinalWorkflows installed
data(cardinal, package="CardinalWorkflows")
cardinal2 <- as(cardinal, "MSImagingExperiment")
```


# Pre-processing

A major change in *Cardinal 2* from earlier versions is how pre-processing is handled.

Instead of applying pre-processing immediately, each pre-processing step is queued to the dataset, and only applied once `process()` is called.

This approach is more computationally and memory efficient in most cases, as ideally each spectrum is only processed once, and no extraneous copies of the data are made.

## Delayed processing with `process()`

On its own, the `process()` method queues a new pre-processing function, and then applies all currently queued processing functions.

For example, the following code applies very basic total-ion-current (TIC) normalization to all spectra.

```{r process-1}
mse_tic <- process(mse, function(x) length(x) * x / sum(x), label="norm")
mse_tic
```

By default, this is applied immediately. However, `delay=TRUE` delays this, and allows us to queue multiple pre-processing functions at once.

```{r process-2}
mse_pre <- mse %>%
	process(function(x) length(x) * x / sum(x), label="norm", delay=TRUE) %>%
	process(function(x) signal::sgolayfilt(x), label="smooth", delay=TRUE)

processingData(mse_pre)
```

We can view all pending and completed pre-processing steps in more detail.

```{r process-3}
mcols(processingData(mse_pre))[,-1]
```

Calling `process()` on the dataset again without any other arguments will apply all queued pre-processing steps.

```{r process-4}
mse_proc <- process(mse_pre)
mse_proc
```

Note that subsetting retains any queued pre-processing steps.

```{r process-5}
mse_pre %>%
	subsetPixels(x <= 3, y <= 3) %>%
	subsetFeatures(mz <= 1000) %>%
	process()
```

All pre-processing methods for `MSImagingExperiment` queue delayed processing by default.

If this is not desired, you can set `options(Cardinal.delay=FALSE)` to apply all pre-processing steps immediately.

## Normalization

Use `normalize()` to queue normalization to an `MSImagingExperiment`.

```{r normalize}
mse_pre <- normalize(mse, method="tic")
```

- `method="tic"` performs total-ion-current (TIC) normalization

- `method="rms"` performs root-mean-square (RMS) normalization

- `method="reference"` normalizes all spectra to a reference feature

TIC normalization is one of the most common normalization methods for mass spectrometry imaging. For comparison between datasets, TIC normalization requires that all spectra are the same length. RMS normalization is more appropriate when spectra are of different lengths.

Normalization to a reference is the most reliable form of normalization, but is only possible when the experiment contains a known reference peak with a constant abundance throughout the dataset. This is often not possible in unsupervised and exploratory experiments.

## Spectral smoothing

Use `smoothSignal()` to queue spectral smoothing to an `MSImagingExperiment`.

```{r smoothSignal-plot, fig.height=7, fig.width=9, results='hide'}
mse %>% smoothSignal(method="gaussian") %>%
	subsetPixels(x==10, y==10, run=="run0") %>%
	process(plot=TRUE,
			par=list(main="Gaussian smoothing", layout=c(3,1)))

mse %>% smoothSignal(method="ma") %>%
	subsetPixels(x==10, y==10, run=="run0") %>%
	process(plot=TRUE, par=list(main="Moving average smoothing"))

mse %>% smoothSignal(method="sgolay") %>%
	subsetPixels(x==10, y==10, run=="run0") %>%
	process(plot=TRUE, par=list(main="Savitzky-Golay smoothing"))
```

```{r smoothSignal}
mse_pre <- smoothSignal(mse_pre, method="gaussian")
```

- `method="gaussian"` performs smoothing with a Gaussian kernel

- `method="ma"` performs moving average smoothing

- `method="sgolay"` applies a Savitzky-Golay smoothing filter

## Baseline correction

Use `reduceBaseline()` to queue baseline correction to an `MSImagingExperiment`.

```{r reduceBaseline-plot, fig.height=5, fig.width=9, results='hide'}
mse %>% reduceBaseline(method="locmin") %>%
	subsetPixels(x==10, y==10, run=="run0") %>%
	process(plot=TRUE, par=list(main="Local minima", layout=c(2,1)))

mse %>% reduceBaseline(method="median") %>%
	subsetPixels(x==10, y==10, run=="run0") %>%
	process(plot=TRUE, par=list(main="Median interpolation"))
```

```{r reduceBaseline}
mse_pre <- reduceBaseline(mse_pre, method="locmin")
```

- `method="locmin"` interpolates a baseline from local minima

- `method="median"` splits a spectrum into blocks and interpolates from binned medians

## Peak processing

Peak processing encompasses multiple steps, including (1) picking peaks, (2) aligning peaks, (3) filtering peaks, and (4) binning profile spectra to the detected peaks.

Prior to peak detection is a good time to apply the previous processing steps.

```{r process-mse, eval=FALSE}
mse_pre <- process(mse_pre)
```

(This is optional, and not necessary if only the peaks are desired, and if it is acceptable to have peaks with intensities of zero in pixels where that peak was not detected.)

### Peak picking

Use `peakPick()` to queue peak picking to an `MSImagingExperiment`.

```{r peakPick-plot, fig.height=7, fig.width=9, results='hide'}
mse_pre %>% subsetPixels(x==10, y==10, run=="run0") %>%
	process() %>%
	peakPick(method="mad") %>%
	process(plot=TRUE, par=list(main="MAD noise", layout=c(3,1)))

mse_pre %>% subsetPixels(x==10, y==10, run=="run0") %>%
	process() %>%
	peakPick(method="simple") %>%
	process(plot=TRUE,
			par=list(main="Simple SD noise"))

mse_pre %>% subsetPixels(x==10, y==10, run=="run0") %>%
	process() %>%
	peakPick(method="adaptive") %>%
	process(plot=TRUE, par=list(main="Adaptive SD noise"))
```

```{r peakPick}
mse_peaks <- peakPick(mse_pre, method="mad")
```

- `method="mad"` calculates adaptive noise from interpolating local mean absolute deviations

- `method="simple"` calculates a constant noise from standard deviations of low-kurtosis bins

- `method="adaptive"` calculates adaptive noise from standard deviations of low-kurtosis bins

### Peak alignment

Use `peakAlign()` to queue peak alignment to an `MSImagingExperiment`.

```{r peakAlign}
mse_peaks <- peakAlign(mse_pre, tolerance=200, units="ppm")
```

Peaks are matched based on proximity of their *m/z*-values, according to `tolerance`, in either parts-per-millin ("ppm") or absolute ("mz") `units`.

The *m/z*-values of known reference peaks can be provided. If no reference is provided, the mean spectrum is calculated, and the local maxima of the mean spectrum are used as the reference.

### Peak filtering

Use `peakFilter()` to queue peak filtering to an `MSImagingExperiment`.

```{r peakFilter}
mse_peaks <- peakFilter(mse_pre, freq.min=0.05)
```

The proportions of pixels where a peak was detected at each *m/z*-value are calculated. Only peaks with frequencies greater than `freq.min` are retained.

### Peak binning

Use `peakBin()` to queue binning of spectra to reference peaks.

Typically, this is applied to processed profile spectra after peak detection, to extract a more accurate representation of the peak intensities.

```{r peakBin, eval=FALSE}
mse_peaks <- process(mse_peaks)
mse_peaks <- peakBin(mse_pre, ref=mz(mse_peaks), type="height")
mse_peaks <- mse_peaks %>% process()
```

A `tolerance` in either parts-per-million ("ppm") or absolute ("mz") `units` is used to match the reference peaks to local maxima in each spectrum.

The peak is then expanded to the nearest local minima in both directions. The intensity of the peak is then summarized either by the maximum intensity (`type="height")` or sum of intensities (`type="area")`.

Rather than use the *m/z*-values of the detected peaks, we can also use known reference peaks (in this case, from the design of the simulated data).

```{r peakBin-2, fig.height=3, fig.width=9}
mzref <- mz(metadata(mse)$design$featureData)
mse_peaks <- peakBin(mse_pre, ref=mzref, type="height")
mse_peaks <- mse_peaks %>% subsetPixels(x %in% 9:11, y %in% 9:11) %>% process()
plot(mse_peaks, coord=list(x=10, y=10))
```

We typically recommend binning the processed profile spectra to detected or reference peaks to produce centroided spectra suitable for downstream analysis.

It is possible to use the detected and aligned peaks directly (after applying `peakAlign()` and `peakFilter()`), but pixels where a peak was not detected will have zero intensities for those peaks. Moreover, all peak intensities will be the peak heights, even when peak areas may be desired instead. However, using the detected peaks directly does mean that there is no need to calculate and store the processed profile spectra, so this saves on storage space.

Generally, it is preferable and more accurate to bin the processed profile spectra to the detected peaks whenever possible and reasonable.

## Mass alignment

Although peak alignment and peak binning will generally account for small differences in *m/z* between spectra, alignment of the profile spectra is sometimes desireable as well.

Use `mzAlign()` to queue alignment of spectra so that peaks will have a consistent *m/z*-value.

First, we need to simulate spectra that are in need of calibration.

```{r unaligned-spectra, fig.height=3, fig.width=9}
set.seed(2020)
mse4 <- simulateImage(preset=1, npeaks=10, from=500, to=600,
							sdmz=750, units="ppm")

plot(mse4, pixel=185:195, xlim=c(535, 570), key=FALSE, superpose=TRUE)
```

To align the spectra, we need to provide a vector of reference m/z values of expected peaks. Here, we will simply use the peaks of the mean spectrum.

```{r mzAlign1, fig.height=3, fig.width=9}
mse4_mean <- summarizeFeatures(mse4)
mse4_peaks <- peakPick(mse4_mean, SNR=2)
mse4_peaks <- peakAlign(mse4_peaks, tolerance=1000, units="ppm")
mse4_peaks <- process(mse4_peaks)
fData(mse4_peaks)

mse4_align1 <- mzAlign(mse4, ref=mz(mse4_peaks), tolerance=2000, units="ppm")
mse4_align1 <- process(mse4_align1)
plot(mse4_align1, pixel=185:195, xlim=c(535, 570), key=FALSE, superpose=TRUE)
```

If no reference spectrum is provided, the mean spectrum is calculated automatically and used as the reference.

```{r mzAlign2, fig.height=3, fig.width=9}
mse4_align2 <- mzAlign(mse4, tolerance=2000, units="ppm")
mse4_align2 <- process(mse4_align2)
plot(mse4_align2, pixel=185:195, xlim=c(535, 570), key=FALSE, superpose=TRUE)
```

The algorithm will try to match the most intense peaks in the reference to local maxima in each spectrum, within `tolerance`. If `tolerance` is too small, the matching local maxima may not be found. If `tolerance` is too large, then peaks may be matched to the wrong local maxima.

## Mass binning

While the *m/z* binning scheme of `MSProcessedImagingExperiment` objects can be adjusted on-the-fly, this does not apply to other types of `MSImagingExperiment`.

Use `mzBin()` to queue binning of spectra to new *m/z*-values.

```{r mzBin, fig.height=3, fig.width=9}
mse_bin <- mzBin(mse_pre, from=1000, to=1600, resolution=1000, units="ppm")
mse_bin <- subsetPixels(mse_bin, x %in% 9:11, y %in% 9:11) %>% process()
plot(mse_bin, coord=list(x=10, y=10))
```

This is useful if you need to combine datasets with different *m/z*-values.

## Mass filtering

Sometimes it is necessary to filter the mass features of a dataset that has not been peak picked and aligned. For example, to remove noisy or low-intensity *m/z*-values.

Use `mzFilter()` to queue filtering of mass features.

```{r mzFilter, fig.height=3, fig.width=9}
mse_filt <- mzFilter(mse_pre, freq.min=0.05)
mse_filt <- subsetPixels(mse_filt, x %in% 9:11, y %in% 9:11) %>% process()
plot(mse_filt, coord=list(x=10, y=10), type='h')
```

`mzFilter()` and `peakFilter()` are actually the same function internally, but with different defaults for profile and centroided spectra, respectively.

Note that `mzFilter()` this does *not* set `centroided()` to `TRUE`; it is up to the user to decide whether the result represent centroided spectra or not, and set `centroided()` appropriately.

## Example processing workflow

Delayed pre-processing makes it easy to chain together multiple pre-processing steps with the `%>%` operator, and then apply them all at once.

```{r process-workflow, fig.height=5, fig.width=9, results='hide'}
mse_proc <- mse %>%
	normalize() %>%
	smoothSignal() %>%
	reduceBaseline() %>%
	peakPick()

# preview processing
mse_proc %>%
	subsetPixels(x == 10, y == 10, run == "run0") %>%
	process(plot=TRUE, par=list(layout=c(2,2)))
```

```{r process-workflow-2, eval=FALSE}
# process detected peaks
mse_peakref <- mse_proc %>%
	peakAlign() %>%
	peakFilter() %>%
	process()

# bin profile spectra to peaks
mse_peaks <- mse %>%
	normalize() %>%
	smoothSignal() %>%
	reduceBaseline() %>%
	peakBin(mz(mse_peakref))
```








# Advanced operations on `MSImagingExperiment`

Internally, most methods that iterate over pixels or mass features use some combination of `pixelApply()`, `featureApply()`, and `spatialApply()`.

While `summarize()` is useful for summarizing a `MSImagingExperiment`, it is limited in that it can only apply summary functions that return a single value, which can be simplified into the columns of a `MassDataFrame` or `PositionDataFrame`.

By contrast, these functions (like `apply()` and `lapply()`) can return any value.

## Using `pixelApply()` and `featureApply()`

`pixelApply()` is used to apply functions over pixels.

```{r pixelApply, fig.height=4, fig.width=9}
# calculate the TIC for every pixel
tic <- pixelApply(mse, sum)

image(mse, tic ~ x * y)
```

`featureApply()` is used to apply functions over features.

```{r featureApply, fig.height=3, fig.width=9}
# calculate the mean spectrum
smean <- featureApply(mse, mean)

plot(mse, smean ~ mz)
```

Note that `featureApply()` will typically be slower than `pixelApply()` for out-of-memory data for `MSProcessedImagingExperiment` objects, due to the way the data is stored.







# Parallel computing using *BiocParallel*

All pre-processing methods and most statistical analysis methods in *Cardinal 2* can be executed in parallel using *BiocParallel*.

By default, a serial backend is used (no parallelization). This is for maximum stability and compatibility.

## Using `BPPARAM`

Any method that supports parallelization includes `BPPARAM` as an argument (see method documentation). The `BPPARAM` argument can be used to specify a parallel backend for the operation, such as `SerialParam()`, `MulticoreParam()`, `SnowParam()`, etc.

```{r eval=FALSE}
# run in parallel, rather than serially
tic <- pixelApply(mse, sum, BPPARAM=MulticoreParam())
```

## Backend types

Several parallelization backends are available, depending on OS:

- `SerialParam()` creates a serial (non-parallel) backend. Use this to avoid potential issues caused by parallelization.

- `MulticoreParam()` creates a multicore backend by forking the current R session. This is typically the fastest parallelization option, but is only available on macOS and Linux.

- `SnowParam()` creates a SNOW backend by creating new R sessions via socket connections. This is typically slower than multicore, but is available on all platforms including Windows.

Use of `MulticoreParam()` will frequently improve speed on macOS and Linux dramatically. However, due to the extra overhead of `SnowParam()`, Windows users may prefer the default `SerialParam()`, depending on the size of the dataset.

## Getting available backends

Available backends can be viewed with `BiocParallel::registered()`.

```{r registered}
BiocParallel::registered()
```

The current backend used by Cardinal can be viewed with `getCardinalBPPARAM()`:

```{r getCardinalBPPARAM}
getCardinalBPPARAM()
```

## Setting a parallel backend

A new default backend can be set for use with Cardinal by calling `setCardinalBPPARAM()`.

```{r setCardinalBPPARAM, eval=FALSE}
# register a SNOW backend
setCardinalBPPARAM(SnowParam())
```

See the *BiocParallel* package documentation for more details on available parallel backends.

## RNG and reproducibility

For methods that rely on random number generation to be reproducible when run in parallel, the RNG must be set to "L'Ecuyer-CMRG" before setting a seed.

```{r RNGkind, eval=FALSE}
RNGkind("L'Ecuyer-CMRG")
set.seed(1)
```



# Session information

```{r session-info}
sessionInfo()
```



